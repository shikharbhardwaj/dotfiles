"
" Vundle config begin 
"
set nocompatible              " be iMproved, required
filetype off                  " required
" set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
" let Vundle manage Vundle, required
Plugin 'VundleVim/Vundle.vim'
" Git in vim
Plugin 'tpope/vim-fugitive'
" The sparkup vim script is in a subdirectory of this repo called vim.
" Pass the path to set the runtimepath properly.
Plugin 'rstacruz/sparkup', {'rtp': 'vim/'}
" UltiSnips
" Track the engine.
Plugin 'SirVer/ultisnips'
" Code snippets for UltiSnips
Plugin 'honza/vim-snippets'
" ctrlp
Plugin 'kien/ctrlp.vim'
" SuperTab
Plugin 'ervandew/supertab'
" Tagbar
Plugin 'majutsushi/tagbar'
" YCM
Bundle 'Valloric/YouCompleteMe'
" Indentation for python
Plugin 'vim-scripts/indentpython.vim'
" PEP8 checking for python
Plugin 'chriskempson/base16-vim'
" Manage Lightline using vundle
Plugin 'itchyny/lightline.vim'
" Enhanced C++ highlighting
Plugin 'octol/vim-cpp-enhanced-highlight'
" Seamless navigation within splits and panes
Bundle 'christoomey/vim-tmux-navigator'
" All of your Plugins must be added before the following line
call vundle#end()            " required
filetype plugin indent on    " required
" Vundle config end
" Vim configuration file
" No toolbar/scrollbars and other crap
set guioptions=aem
set esckeys
set scrolloff=5
" Font (required for lightline)
if has('gui_running')
    set guifont=Source\ Code\ Pro\ for\ Powerline\ Medium\ 10
endif
" Settings for lightline
let g:lightline = {
            \ 'colorscheme': 'powerline',
            \ 'active': {
            \   'left': [ [ 'mode', 'paste' ],
            \             [ 'fugitive', 'filename' ] ]
            \ },
            \ 'component_function': {
            \   'fugitive': 'LightLineFugitive',
            \   'readonly': 'LightLineReadonly',
            \   'modified': 'LightLineModified',
            \   'filename': 'LightLineFilename'
            \ },
            \ 'separator': { 'left': '', 'right': '' },
            \ 'subseparator': { 'left': '', 'right': '' }
            \ }

function! LightLineModified()
    if &filetype == "help"
        return ""
    elseif &modified
        return "+"
    elseif &modifiable
        return ""
    else
        return ""
    endif
endfunction

function! LightLineReadonly()
    if &filetype == "help"
        return ""
    elseif &readonly
        return ""
    else
        return ""
    endif
endfunction

function! LightLineFugitive()
    if exists("*fugitive#head")
        let _ = fugitive#head()
        return strlen(_) ? ' '._ : ''
    endif
    return ''
endfunction

function! LightLineFilename()
    return ('' != LightLineReadonly() ? LightLineReadonly() . ' ' : '') .
                \ ('' != expand('%:t') ? expand('%:t') : '[No Name]') .
                \ ('' != LightLineModified() ? ' ' . LightLineModified() : '')
endfunction

set autoread " File change detection
" make backspace behave in a sane manner
set backspace=indent,eol,start
" Indentation settings
" Tab width = 4

set ts=4
set sts=4
set sw=4
set textwidth=80
set expandtab
" Line number settings
" Use only relative line numbers in the gutter
" Absolute line numbers are present in the status line
set rnu
" Modify the gutter
set numberwidth=4
" Highlight the current line
set cursorline
" Fast redraw
set ttyfast
" Use autoindent and smartindent
set autoindent
set smartindent
" Use UNIX style line endings
set fileformat=unix
" Colorscheme settings
colorscheme solarized
" We use a 256 color terminal
let base16colorspace=256
set background=dark
" Set the 81 column to gray so that lines dont grow too big
set colorcolumn=81
highlight ColorColumn ctermbg=darkgray
" Build system
" Compile and run C++
autocmd filetype cpp nnoremap <F4>  :!clang++-3.6 % -Wall -Werror -pthread -pedantic -std=c++14 -I../headers -I$HOME/bin -o '%:r' && './%:r'<CR>
" Compile and debug C++
autocmd filetype cpp nnoremap <F7>  :!clang++-3.6 % -Wall -pthread -pedantic -std=c++14  -I../headers -I$HOME/bin -g -o '%:r' && gdb '%:r'<CR>
" Compile and run C
autocmd filetype c nnoremap <F4>  :!gcc % -Wall -std=c11 -pthread -pedantic -lm -o '%:r' && './%:r'<CR>
" Make all targets
nnoremap <F8> :!make all<CR>
" Run python3
autocmd filetype python nnoremap <F4> :!python3 %<CR>
" Reindent file and return to same line(kind of an anti pattern)
nnoremap <F6>  gg=G''
" CTRL V splits vertically
nnoremap <C-v> :vsp<CR>
" CTRL A splits horizontally
nnoremap <C-a> :sp<CR>
set splitbelow
set splitright
" Split navigation with ctrl
nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>
nnoremap <C-L> <C-W><C-L>
nnoremap <C-H> <C-W><C-H>
" Text movement with arrow keys
nmap <Up> [e
nmap <Down> ]e
vmap <Up> [egv
vmap <Down> ]egv
nmap <Left> <<
nmap <Right> >>
vmap <Left> <gv
vmap <Right> >gv
" tab completetion on paths
set wildmode=full
" Enable status line
set laststatus=2
" Code folding settings
set foldmethod=syntax " fold based on indent
set foldnestmax=10 " deepest fold is 10 levels
set nofoldenable " don't fold by default
set foldlevel=1
" Wrap settings
set wrap "turn on line wrapping
set wrapmargin=8 " wrap lines when coming within n characters from side
set linebreak " set soft wrapping
set showbreak=… " show ellipsis at breaking
" Settings for NERDtree
" Uncomment below to start off with NERDTree open
" autocmd VimEnter * NERDTree
autocmd VimEnter * wincmd p
let g:NERDTreeWinPos = "right"
nnoremap <F9> :NERDTreeToggle<CR>
let g:NERDTreeWinSize=24
" Filetypes for NERDcommenter
filetype plugin on
" Let , be the leader key
let mapleader=","
autocmd BufEnter * silent! lcd %:p:h
" Syntastic settings
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*
" Read the vimrc from current dir
set exrc
"
" YouCompleteMe options
"
" Check if the configuration file exists in the project
" for custom configs for each project
if filereadable("../cfg/ycm_extra_conf.py")
    let g:ycm_global_ycm_extra_conf = '../cfg/ycm_extra_conf.py'
else
    let g:ycm_global_ycm_extra_conf = '~/.vim/.ycm_extra_conf.py'
endif
"will put icons in Vim's gutter on lines that have a diagnostic set.
"Turning this off will also turn off the YcmErrorLine and YcmWarningLine
"highlighting
let g:ycm_enable_diagnostic_signs = 1
let g:ycm_enable_diagnostic_highlighting = 1
let g:ycm_always_populate_location_list = 1 "default 0
" let g:ycm_open_loclist_on_ycm_diags = 1 "default 1

let g:ycm_always_populate_loc_list = 1
let g:ycm_auto_loc_list = 1
let g:ycm_check_on_open = 1
let g:ycm_check_on_wq = 0

" let g:ycm_complete_in_strings = 1 "default 1
let g:ycm_collect_identifiers_from_tags_files = 0 "default 0
" let g:ycm_path_to_python_interpreter = '' "default ''


" let g:ycm_server_use_vim_stdout = 0 "default 0 (logging to console)
" let g:ycm_server_log_level = 'info' "default info

let g:ycm_goto_buffer_command = 'same-buffer' "[ 'same-buffer', 'horizontal-split', 'vertical-split', 'new-tab' ]
let g:ycm_filetype_whitelist = { '*': 1 }
let g:ycm_key_invoke_completion = '<C-Space>'
highlight YcmErrorSection guifg=#eeeeee
set completeopt-=preview
let g:ycm_add_preview_to_completeopt=0
" Config for UltiSnips
" make YCM compatible with UltiSnips (using supertab)
let g:ycm_key_list_select_completion = ['<C-n>', '<Down>']
let g:ycm_key_list_previous_completion = ['<C-p>', '<Up>']
let g:SuperTabDefaultCompletionType = '<C-n>'

" better key bindings for UltiSnipsExpandTrigger
let g:UltiSnipsExpandTrigger = "<tab>"
let g:UltiSnipsJumpForwardTrigger = "<tab>"
let g:UltiSnipsJumpBackwardTrigger = "<s-tab>"
" Remap esc to something else
ino jk <esc>
cno jk <c-c>
vno v <esc>
" Use shift+arrows to copy above or below
nmap <S-Down> 0v$"+yojk"+gPddk
nmap <S-Up> 0v$"+yOjk"+gPddk
" Window title
let &titlestring = "Vim"
if &term == "screen"
    set t_ts=^[k
    set t_fs=^[\
endif
if &term == "screen"
    set title
endif
" Ctags
set tags=~/.vim/tags/cpp_tags
" CtrlP
set runtimepath^=~/.vim/bundle/ctrlp.vim
let g:ctrlp_map = '<c-p>'
let g:ctrlp_cmd = 'CtrlP'
nnoremap <leader>. :CtrlPTag<cr>
" Tagbar
set runtimepath^=~/.vim/bundle/tagbar
nnoremap <silent> <Leader>b :TagbarToggle<CR>
let g:tagbar_width = 30
let s:width = 80
" Numpad needed
set noek
" We use a 256 color terminal
set t_Co=256
" Escape/unescape & < > HTML entities in range (default current line).
function! HtmlEntities(line1, line2, action)
    let search = @/
    let range = 'silent ' . a:line1 . ',' . a:line2
    if a:action == 0  " must convert &amp; last
        execute range . 'sno/&lt;/</eg'
        execute range . 'sno/&gt;/>/eg'
        execute range . 'sno/&amp;/&/eg'
    else              " must convert & first
        execute range . 'sno/&/&amp;/eg'
        execute range . 'sno/</&lt;/eg'
        execute range . 'sno/>/&gt;/eg'
    endif
    nohl
    let @/ = search
endfunction
command! -range -nargs=1 Entities call HtmlEntities(<line1>, <line2>, <args>)
noremap <silent> \h :Entities 0<CR>
noremap <silent> \H :Entities 1<CR>
" Make shift+arrow work on tmux
if &term =~ '^screen'
    " tmux will send xterm-style keys when its xterm-keys option is on
    execute "set <xUp>=\e[1;*A"
    execute "set <xDown>=\e[1;*B"
    execute "set <xRight>=\e[1;*C"
    execute "set <xLeft>=\e[1;*D"
endif
set clipboard=unnamed
let python_highlight_all = 1
" Enable editing encrypted files
" Transparent editing of gpg encrypted files.
augroup encrypted
au!
" First make sure nothing is written to ~/.viminfo while editing
" an encrypted file.
autocmd BufReadPre,FileReadPre      *.gpg set viminfo=
" We don't want a swap file, as it writes unencrypted data to disk
autocmd BufReadPre,FileReadPre      *.gpg set noswapfile
" Switch to binary mode to read the encrypted file
autocmd BufReadPre,FileReadPre      *.gpg set bin
autocmd BufReadPre,FileReadPre      *.gpg let ch_save = &ch|set ch=2
autocmd BufReadPre,FileReadPre      *.gpg let shsave=&sh
autocmd BufReadPre,FileReadPre      *.gpg let &sh='sh'
autocmd BufReadPre,FileReadPre      *.gpg let ch_save = &ch|set ch=2
autocmd BufReadPost,FileReadPost    *.gpg '[,']!gpg --decrypt --default-recipient-self 2> /dev/null
autocmd BufReadPost,FileReadPost    *.gpg let &sh=shsave
" Switch to normal mode for editing
autocmd BufReadPost,FileReadPost    *.gpg set nobin
autocmd BufReadPost,FileReadPost    *.gpg let &ch = ch_save|unlet ch_save
autocmd BufReadPost,FileReadPost    *.gpg execute ":doautocmd BufReadPost " . expand("%:r")
" Convert all text to encrypted text before writing
autocmd BufWritePre,FileWritePre    *.gpg set bin
autocmd BufWritePre,FileWritePre    *.gpg let shsave=&sh
autocmd BufWritePre,FileWritePre    *.gpg let &sh='sh'
autocmd BufWritePre,FileWritePre    *.gpg '[,']!gpg --encrypt --default-recipient-self 2>/dev/null
autocmd BufWritePre,FileWritePre    *.gpg let &sh=shsave
" Undo the encryption so we are back in the normal text, directly
" after the file has been written.
autocmd BufWritePost,FileWritePost  *.gpg silent u
autocmd BufWritePost,FileWritePost  *.gpg set nobin
augroup END
" Show invisibles
" Shortcut to rapidly toggle `set list`
nmap <leader>l :set list!<CR>
" Use the same symbols as TextMate for tabstops and EOLs
set listchars=tab:▸\ ,eol:¬
function! BeforeWrite()
    let a:cursor_pos = getpos(".")
    execute "%!clang-format-3.6 -style='{BasedOnStyle: llvm, IndentWidth: 4}'"
    call setpos('.', a:cursor_pos)
endfunction
autocmd FileType c,cpp autocmd BufWritePre <buffer> :call BeforeWrite()
